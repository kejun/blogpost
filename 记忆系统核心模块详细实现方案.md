# 记忆系统核心模块详细实现方案

**文档日期：** 2026年2月13日

---

## 一、混合检索系统 (Hybrid Retrieval System)

### 1.1 核心数据结构

```typescript
// 记忆块接口
interface MemoryChunk {
  // 唯一标识
  id: string;
  
  // 记忆内容
  content: string;
  embedding?: number[];
  
  // 元数据
  metadata: {
    source: 'conversation' | 'user_input' | 'system' | 'inference';
    source_id?: string;
    created_at: number;
    updated_at: number;
    expires_at?: number;
    access_count: number;
    last_accessed_at?: number;
    category?: 'fact' | 'preference' | 'context' | 'skill' | 'relationship';
    tags?: string[];
    user_id?: string;
    session_id?: string;
    agent_id?: string;
    version: number;
    parent_id?: string;
    confidence: number;
    verified: boolean;
  };
  
  // 混合检索支持
  exact_keys?: Record<string, string | number | boolean>;
  temporal_start?: number;
  temporal_end?: number;
  position?: {
    conversation_id: string;
    message_index: number;
    char_range?: { start: number; end: number };
  };
}

// 检索选项
interface RetrievalOptions {
  strategy?: 'auto' | 'exact' | 'semantic' | 'temporal' | 'hybrid';
  intent?: 'fact' | 'reasoning' | 'contextual' | 'preference' | 'skill';
  limit?: number;
  offset?: number;
  filters?: {
    categories?: string[];
    tags?: string[];
    user_ids?: string[];
    confidence_min?: number;
    verified_only?: boolean;
    time_range?: { start: number; end: number };
  };
  sort_by?: 'relevance' | 'recency' | 'confidence' | 'hybrid';
  sort_order?: 'asc' | 'desc';
  hybrid_weights?: {
    exact_match?: number;
    semantic?: number;
    temporal?: number;
    recency?: number;
  };
}

// 检索结果
interface HybridResult {
  memory: MemoryChunk;
  scores: {
    exact_score?: number;
    semantic_score: number;
    temporal_score?: number;
    recency_score?: number;
    final_score: number;
  };
  match_details?: {
    matched_terms?: string[];
    matched_exact_keys?: Record<string, any>;
    matched_context?: string;
    snippet?: string;
  };
  source_trace?: {
    retrieved_from: 'vector' | 'kv' | 'temporal';
    retrieval_time_ms: number;
  };
}
```

### 1.2 混合检索核心算法

```python
import numpy as np
from typing import List, Dict, Tuple
from dataclasses import dataclass
import asyncio
import hashlib
import json
from datetime import datetime

@dataclass
class SearchContext:
    query: str
    intent: str
    timestamp: float
    user_id: Optional[str]
    session_id: Optional[str]

class HybridRetrievalEngine:
    """
    混合检索引擎
    
    支持多种检索策略的智能组合：
    1. 精确匹配 (Exact Match)
    2. 语义搜索 (Semantic Search)
    3. 时间查询 (Temporal Query)
    4. 混合融合 (Hybrid Fusion)
    """
    
    def __init__(
        self,
        vector_store,
        kv_store,
        temporal_index,
        config: HybridRetrievalConfig
    ):
        self.vector_store = vector_store
        self.kv_store = kv_store
        self.temporal_index = temporal_index
        self.config = config
        self.embedding_model = None
        self._cache = LRUCache(
            max_size=config.cache.max_size,
            ttl=config.cache.ttl_seconds
        )
    
    async def retrieve(
        self,
        query: str,
        options: RetrievalOptions = None
    ) -> List[HybridResult]:
        """核心检索方法"""
        options = options or RetrievalOptions()
        
        # 1. 推断检索意图
        intent = options.intent or await self._infer_intent(query)
        
        # 2. 生成查询嵌入
        embedding = await self._get_embedding(query)
        
        # 3. 确定检索策略
        strategy = options.strategy or self._determine_strategy(intent)
        
        # 4. 并行执行多路检索
        search_tasks = self._create_search_tasks(
            query=query,
            embedding=embedding,
            intent=intent,
            strategy=strategy,
            options=options
        )
        
        # 并发执行
        results_dict = await self._execute_parallel(search_tasks)
        
        # 5. 融合结果
        fused_results = await self._fuse_results(
            results_dict=results_dict,
            query=query,
            intent=intent,
            strategy=strategy,
            options=options
        )
        
        # 6. 过滤和排序
        final_results = self._filter_and_sort(
            results=fused_results,
            options=options
        )
        
        return final_results[:options.limit or 10]
    
    async def _infer_intent(self, query: str) -> str:
        """基于关键词推断查询意图"""
        query_lower = query.lower()
        
        intent_keywords = {
            'fact': ['who', 'what', 'when', 'where', '是什么', '谁', '何时'],
            'reasoning': ['why', 'how', '为什么', '如何', '解释', '原理'],
            'contextual': ['remember', 'earlier', 'previous', 'recall', '记得', '之前'],
            'preference': ['prefer', 'like', 'hate', '喜欢', '讨厌', '偏好'],
            'skill': ['how to', '怎么做', '方法', '技巧', '步骤']
        }
        
        intent_scores = {}
        for intent, keywords in intent_keywords.items():
            score = sum(1 for kw in keywords if kw in query_lower)
            if score > 0:
                intent_scores[intent] = score
        
        if intent_scores:
            return max(intent_scores, key=intent_scores.get)
        
        return 'reasoning'
    
    def _determine_strategy(self, intent: str) -> str:
        """根据意图确定检索策略"""
        strategy_map = {
            'fact': 'hybrid',
            'reasoning': 'semantic',
            'contextual': 'temporal',
            'preference': 'hybrid',
            'skill': 'semantic'
        }
        return strategy_map.get(intent, 'hybrid')
    
    async def _search_exact(
        self,
        key: str,
        options: RetrievalOptions
    ) -> List[HybridResult]:
        """精确匹配搜索"""
        start_time = time.perf_counter()
        results = []
        
        memory = await self.kv_store.get(key)
        if memory:
            results.append(HybridResult(
                memory=memory,
                scores={'exact_score': 1.0, 'semantic_score': 0, 'final_score': 1.0},
                source_trace={'retrieved_from': 'kv', 'retrieval_time_ms': (time.perf_counter() - start_time) * 1000}
            ))
        
        return results
    
    async def _search_semantic(
        self,
        query: str,
        embedding: List[float],
        options: RetrievalOptions
    ) -> List[HybridResult]:
        """语义搜索"""
        start_time = time.perf_counter()
        
        vector_results = await self.vector_store.search(
            query=query,
            embedding=embedding,
            options=options
        )
        
        results = []
        for match in vector_results:
            results.append(HybridResult(
                memory=match.memory,
                scores={'semantic_score': match.similarity, 'final_score': match.similarity},
                source_trace={'retrieved_from': 'vector', 'retrieval_time_ms': (time.perf_counter() - start_time) * 1000}
            ))
        
        return results
    
    async def _search_temporal(
        self,
        time_range: Tuple[float, float],
        query: str,
        options: RetrievalOptions
    ) -> List[HybridResult]:
        """时间范围搜索"""
        start_time = time.perf_counter()
        
        memories = await self.temporal_index.query(
            time_range=time_range,
            filters=options.filters
        )
        
        results = []
        for memory in memories:
            recency_score = self._calculate_recency_score(
                memory.metadata.created_at,
                time_range[1]
            )
            results.append(HybridResult(
                memory=memory,
                scores={'temporal_score': recency_score, 'final_score': recency_score},
                source_trace={'retrieved_from': 'temporal', 'retrieval_time_ms': (time.perf_counter() - start_time) * 1000}
            ))
        
        return results
    
    async def _fuse_results(
        self,
        results_dict: Dict[str, List[HybridResult]],
        query: str,
        intent: str,
        strategy: str,
        options: RetrievalOptions
    ) -> List[HybridResult]:
        """多路结果融合"""
        all_results = []
        seen_ids = set()
        
        for source, results in results_dict.items():
            for result in results:
                if result.memory.id not in seen_ids:
                    seen_ids.add(result.memory.id)
                    all_results.append(result)
        
        weights = options.hybrid_weights or self.config.default_weights
        
        for result in all_results:
            scores = result.scores
            fused_score = (
                (scores.get('exact_score', 0) * weights.exact_match if 'exact_score' in scores else 0) +
                (scores.get('semantic_score', 0) * weights.semantic if 'semantic_score' in scores else 0) +
                (scores.get('temporal_score', 0) * weights.temporal if 'temporal_score' in scores else 0)
            )
            result.scores['final_score'] = fused_score
        
        all_results.sort(key=lambda r: r.scores['final_score'], reverse=True)
        return all_results
    
    def _calculate_recency_score(
        self,
        created_at: float,
        reference_time: float
    ) -> float:
        """计算新近度分数（0-1）"""
        max_diff = 30 * 24 * 60 * 60  # 30天
        diff = reference_time - created_at
        
        if diff < 0:
            return 1.0
        elif diff > max_diff:
            return 0.0
        else:
            return 1.0 - (diff / max_diff)
```

### 1.3 向量存储实现（基于 Milvus）

```python
from milvus import MilvusClient
import numpy as np
from typing import List, Dict

class MilvusVectorStore:
    """Milvus 向量存储实现"""
    
    def __init__(
        self,
        connection_args: Dict,
        collection_name: str = "memory_chunks",
        embedding_dim: int = 1024,
        metric_type: str = "COSINE"
    ):
        self.client = MilvusClient(**connection_args)
        self.collection_name = collection_name
        self.embedding_dim = embedding_dim
        self.metric_type = metric_type
        self._init_collection()
    
    def _init_collection(self):
        """初始化集合"""
        if self.client.has_collection(self.collection_name):
            return
        
        self.client.create_collection(
            collection_name=self.collection_name,
            dimension=self.embedding_dim,
            metric_type=self.metric_type,
            max_model_size=1024
        )
        
        self.client.create_index(
            collection_name=self.collection_name,
            field_name="embedding",
            index_type="IVF_FLAT",
            params={"nlist": 1024, "nprobe": 32}
        )
    
    async def search(
        self,
        query: str,
        embedding: List[float],
        options: RetrievalOptions
    ) -> List[SemanticMatch]:
        """向量搜索"""
        search_params = {
            "metric_type": self.metric_type,
            "params": {"nprobe": options.limit or 32}
        }
        
        results = self.client.search(
            collection_name=self.collection_name,
            data=[embedding],
            top_k=options.limit or 50,
            params=search_params,
            output_fields=["id", "content", "metadata", "created_at", "access_count"]
        )
        
        matches = []
        for result in results[0]:
            matches.append(SemanticMatch(
                memory=await self._id_to_memory(result.id),
                similarity=1 - result.distance,
                embedding=embedding
            ))
        
        return matches
    
    async def upsert(
        self,
        id: str,
        embedding: List[float],
        metadata: Dict
    ) -> None:
        """插入或更新向量"""
        self.client.upsert(
            collection_name=self.collection_name,
            data=[{
                "id": id,
                "embedding": embedding,
                "content": metadata.get("content", ""),
                "metadata": json.dumps(metadata),
                "created_at": metadata.get("created_at", time.time())
            }]
        )
```

---

## 二、记忆版本控制系统

### 2.1 核心数据结构

```python
@dataclass
class MemoryRecord:
    """单条记忆记录"""
    id: str
    content: str
    embedding: Optional[List[float]] = None
    metadata: Dict = field(default_factory=dict)
    version: int = 1
    parent_id: Optional[str] = None
    root_id: Optional[str] = None
    created_at: float = field(default_factory=time.time)
    updated_at: float = field(default_factory=time.time)
    expires_at: Optional[float] = None
    source: str = "inference"
    source_id: Optional[str] = None
    access_count: int = 0
    last_accessed_at: Optional[float] = None
    category: str = "general"
    tags: List[str] = field(default_factory=list)
    confidence: float = 0.5
    verified: bool = False
    deleted_at: Optional[float] = None
```

### 2.2 版本控制引擎

```python
class MemoryVersionEngine:
    """
    记忆版本控制引擎
    
    核心功能：
    1. 版本创建与追踪
    2. 完整变更历史
    3. 版本比较与差异
    4. 时间旅行查询
    5. 冲突检测
    """
    
    def __init__(self, storage_backend):
        self.storage = storage_backend
        self._version_index: Dict[str, List[str]] = defaultdict(list)
        self._content_hash_index: Dict[str, str] = {}
        self._diff_detector = DiffDetector()
    
    async def create(
        self,
        memory: MemoryRecord,
        operator: str = "system",
        reason: Optional[str] = None
    ) -> MemoryVersion:
        """创建新记忆（v1）"""
        memory.id = memory.id or str(uuid.uuid4())
        memory.root_id = memory.id
        memory.version = 1
        
        content_hash = self._compute_hash(memory.content)
        
        version = MemoryVersion(
            version_id=str(uuid.uuid4()),
            memory_id=memory.id,
            root_id=memory.root_id,
            version_number=1,
            parent_version_id=None,
            content_hash=content_hash,
            content_snapshot=memory.content,
            metadata_snapshot=memory.metadata.copy(),
            operation="create",
            operator=operator,
            created_at=time.time(),
            reason=reason,
            diff=None
        )
        
        await self.storage.save_memory(memory)
        await self.storage.save_version(version)
        
        self._version_index[memory.id].append(version.version_id)
        self._content_hash_index[content_hash] = memory.id
        
        return version
    
    async def update(
        self,
        memory_id: str,
        new_content: str,
        new_metadata: Optional[Dict] = None,
        operator: str = "system",
        reason: Optional[str] = None
    ) -> Tuple[MemoryRecord, MemoryVersion]:
        """更新记忆（创建新版本）"""
        current_memory = await self.storage.get_memory(memory_id)
        if not current_memory:
            raise ValueError(f"Memory not found: {memory_id}")
        
        current_version = await self.storage.get_latest_version(memory_id)
        new_hash = self._compute_hash(new_content)
        
        diff = self._diff_detector.detect(
            old_content=current_memory.content,
            new_content=new_content,
            old_metadata=current_memory.metadata,
            new_metadata=new_metadata or {}
        )
        
        if new_hash == current_memory.content_hash:
            current_memory.updated_at = time.time()
            await self.storage.save_memory(current_memory)
            return current_memory, current_version
        
        current_memory.content = new_content
        current_memory.embedding = None
        current_memory.version += 1
        current_memory.updated_at = time.time()
        
        if new_metadata:
            current_memory.metadata.update(new_metadata)
        
        new_version = MemoryVersion(
            version_id=str(uuid.uuid4()),
            memory_id=memory_id,
            root_id=current_memory.root_id,
            version_number=current_memory.version,
            parent_version_id=current_version.version_id,
            content_hash=new_hash,
            content_snapshot=new_content,
            metadata_snapshot=current_memory.metadata.copy(),
            operation="update",
            operator=operator,
            created_at=time.time(),
            reason=reason,
            diff=diff
        )
        
        await self.storage.save_memory(current_memory)
        await self.storage.save_version(new_version)
        
        self._version_index[memory_id].append(new_version.version_id)
        self._content_hash_index[new_hash] = memory_id
        
        return current_memory, new_version
    
    async def get_history(
        self,
        memory_id: str,
        include_deleted: bool = False
    ) -> List[MemoryVersion]:
        """获取完整变更历史"""
        versions = await self.storage.get_versions(memory_id)
        
        if not include_deleted:
            versions = [v for v in versions if v.operation != "delete"]
        
        versions.sort(key=lambda v: v.version_number)
        return versions
    
    async def compare(
        self,
        memory_id: str,
        version_a: int,
        version_b: int
    ) -> Dict:
        """比较两个版本"""
        ver_a = await self.storage.get_version_by_number(memory_id, version_a)
        ver_b = await self.storage.get_version_by_number(memory_id, version_b)
        
        if not ver_a or not ver_b:
            raise ValueError("Version not found")
        
        diff = ver_b.diff or self._diff_detector.compare_content(
            ver_a.content_snapshot,
            ver_b.content_snapshot
        )
        
        return {
            "memory_id": memory_id,
            "version_a": {
                "number": ver_a.version_number,
                "timestamp": ver_a.created_at,
                "operator": ver_a.operator
            },
            "version_b": {
                "number": ver_b.version_number,
                "timestamp": ver_b.created_at,
                "operator": ver_b.operator
            },
            "diff": diff,
            "change_count": self._count_changes(diff)
        }
    
    async def detect_conflicts(
        self,
        memory_id: str,
        time_window: str = "30d"
    ) -> List[Dict]:
        """检测记忆冲突"""
        history = await self.get_history(memory_id)
        
        if len(history) < 2:
            return []
        
        window_seconds = self._parse_time_window(time_window)
        now = time.time()
        
        recent_versions = [
            v for v in history
            if now - v.created_at < window_seconds
            and v.operation != "delete"
        ]
        
        conflicts = []
        
        for i, v1 in enumerate(recent_versions):
            for v2 in recent_versions[i+1:]:
                if self._is_contradictory(v1, v2):
                    conflicts.append({
                        "version_1": {
                            "id": v1.version_id,
                            "number": v1.version_number,
                            "timestamp": v1.created_at,
                            "operator": v1.operator,
                            "content_preview": v1.content_snapshot[:100]
                        },
                        "version_2": {
                            "id": v2.version_id,
                            "number": v2.version_number,
                            "timestamp": v2.created_at,
                            "operator": v2.operator,
                            "content_preview": v2.content_snapshot[:100]
                        },
                        "contradiction_type": self._classify_contradiction(v1, v2),
                        "severity": self._assess_severity(v1, v2)
                    })
        
        return conflicts
    
    def _compute_hash(self, content: str) -> str:
        """计算内容哈希"""
        return hashlib.sha256(content.encode()).hexdigest()
    
    def _is_contradictory(self, v1: MemoryVersion, v2: MemoryVersion) -> bool:
        """判断两个版本是否矛盾"""
        c1 = v1.content_snapshot.lower()
        c2 = v2.content_snapshot.lower()
        
        contradiction_patterns = [
            (["是", "不是"], lambda a, b: 
                any(x in a for x in ["是"]) and any(x in b for x in ["不是"])),
            (["喜欢", "讨厌"], lambda a, b:
                any(x in a for x in ["喜欢"]) and any(x in b for x in ["讨厌"])),
        ]
        
        for patterns, checker in contradiction_patterns:
            if any(p in c1 for p in patterns[0]) and any(p in c2 for p in patterns[1]):
                return True
        
        return False
```

---

## 三、记忆路由器

```python
class MemoryRouter:
    """智能记忆路由器"""
    
    INTENTS = {
        "fact": ["who", "what", "when", "where"],
        "reasoning": ["why", "how", "explain"],
        "contextual": ["remember", "earlier", "previous", "recall"]
    }
    
    STRATEGIES = {
        "fact": {
            "primary": "kv_lookup",
            "fallback": "semantic_search",
            "weight": {"kv": 0.7, "vector": 0.3}
        },
        "reasoning": {
            "primary": "semantic_search",
            "fallback": "context_chain",
            "weight": {"vector": 0.8, "context": 0.2}
        },
        "contextual": {
            "primary": "temporal_search",
            "fallback": "semantic_search",
            "weight": {"temporal": 0.6, "vector": 0.4}
        }
    }
    
    async def route(self, query: str) -> Dict:
        """路由到最优检索策略"""
        intent = self._classify(query)
        return self.STRATEGIES.get(intent, self.STRATEGIES["reasoning"])
```

---

## 四、API 接口设计

```python
class MemoryAPI:
    """记忆系统 API"""
    
    async def create_memory(
        self,
        content: str,
        metadata: Dict = None,
        category: str = "general"
    ) -> MemoryRecord:
        """创建记忆"""
        pass
    
    async def retrieve(
        self,
        query: str,
        strategy: str = "auto",
        limit: int = 10
    ) -> List[HybridResult]:
        """检索记忆"""
        pass
    
    async def update_memory(
        self,
        memory_id: str,
        content: str,
        reason: str = None
    ) -> MemoryRecord:
        """更新记忆"""
        pass
    
    async def get_history(
        self,
        memory_id: str
    ) -> List[MemoryVersion]:
        """获取版本历史"""
        pass
    
    async def compare_versions(
        self,
        memory_id: str,
        v1: int,
        v2: int
    ) -> Dict:
        """比较版本"""
        pass
    
    async def detect_conflicts(
        self,
        memory_id: str,
        time_window: str = "30d"
    ) -> List[Dict]:
        """检测冲突"""
        pass
```

---

## 五、配置示例

```yaml
# config.yaml
memory_system:
  # 混合检索配置
  hybrid_retrieval:
    default_weights:
      exact_match: 0.3
      semantic: 0.5
      temporal: 0.2
    thresholds:
      final_score_min: 0.1
    cache:
      enabled: true
      ttl_seconds: 300
      max_size: 10000
  
  # 版本控制配置
  version_control:
    max_history_length: 100
    auto_merge: true
    conflict_detection:
      enabled: true
      time_window: "30d"
  
  # 存储后端
  storage:
    vector:
      provider: "milvus"
      connection:
        uri: "localhost:19530"
      collection: "memory_chunks"
    kv:
      provider: "redis"
      connection:
        host: "localhost"
        port: 6379
    temporal:
      provider: "clickhouse"
      connection:
        host: "localhost"
        port: 8123"
```

---

*文档创建：2026-02-13*
