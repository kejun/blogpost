# 完整翻译：用 Claude Code 实现“净室”Z80 / ZX Spectrum 模拟器

antirez，5 小时前。1334 次浏览。

Anthropic 最近发布了一篇博文，描述了一个实验：让最新版本 Opus（4.6）在“净室（clean room）”设置下，用 Rust 写一个 C 编译器。

这个实验方法让我对他们想证明的点感到怀疑。为什么不把指令集架构（ISA）文档提供给智能体（agent）？为什么是 Rust？写 C 编译器本质上是一个巨大的图操作练习：这类程序在 Rust 里更难写。并且，在净室实验中，智能体应该能访问与优化编译器相关的、已经建立好的计算机科学进展信息：有很多论文很容易被整理成若干 Markdown 文件。SSA、寄存器分配、指令选择与调度。这些事情本应先研究，作为前提，然后实现仍然是“净室”。

不允许智能体访问互联网，也不允许它访问任何其他编译器源码，这当然是正确的。比较难理解的是几乎零引导原则，但如果目标是展示大型项目可被完全自主地写出来，这也算一致。不过我们都知道，在实践里编码智能体大多数时候不是这么用的。谁大量使用编码智能体，谁就非常清楚：哪怕你从不亲自改代码，这里点一下、那里点一下，结果质量都会完全不同。

# Z80 实验

我觉得是时候自己试一个类似实验了：一个最多花一两个小时、并且和我的 Claude Code Max 套餐相匹配的实验。我决定写一个 Z80 模拟器，然后写一个 ZX Spectrum 模拟器（甚至更多，后面会说 CP/M 模拟器），并放在我认为更有意义的“净室”条件下。结果在这里： https://github.com/antirez/ZOT。

# 我使用的流程

1. 我先写了一个 Markdown 文件，描述我想做什么的规格。纯英文、高层想法，定义要实现的 Z80 模拟器范围。我写了类似这样的话：它应该一次执行完整指令，而不是单时钟步，因为这个模拟器要能运行在 RP2350 这种受限硬件上。模拟器应该正确跟踪已经过去的时钟周期（并且我说明了我们之后可以利用这个特性实现 ZX Spectrum 在内存访问期间与 ULA 的争用），提供内存访问回调，并模拟 Z80 所有已知官方与非官方指令。

对于 Spectrum 的实现（作为后续步骤），我在 Markdown 文件里提供了更多信息，比如我希望在 RGB 帧缓冲区（buffer）中如何渲染，以及这需要是可选的，这样嵌入式设备就能在把扫描线传输到 ST77xx 显示器（或类似设备）时直接渲染；还要能够通过 I/O 端口交互设置 EAR 位，以非常真实地模拟磁带加载；以及我对模拟器的很多其他期望。

这个文件还包含了智能体必须遵守的规则，比如：

* 禁止访问互联网，但你可以使用我放在 ./z80-specs 里的规范和测试向量文件。
* 代码应当简单、干净，绝不把事情过度复杂化。
* 每次有实质性进展都要提交到 git 仓库。
* 提交前，你应测试产出是否高质量并且能工作。
* 随着功能增加，编写详细测试套件。每次重大变更都必须重新执行测试。
* 代码应当有非常充分的注释：即使不熟悉某些 Z80 或 Spectrum 内部细节的人，也应该能理解。
* 不要停下来等待提示，用户不在键盘前。
* 在这个文件末尾创建工作进展日志，记录你已经完成了什么、还缺什么。始终更新这个日志。
* 每次上下文压缩后，再读一遍这个文件。

2. 然后，我启动了一个 Claude Code 会话，让它去网上抓取所有关于 Z80（后来 Spectrum 也做了同样的事）的有用文档，并把有用的事实信息提取到 Markdown 文件中。我还提供了用于 Z80 的高强度测试向量二进制文件、ZX Spectrum ROM，以及一些其他可用于测试模拟器是否正确执行代码的二进制文件。信息收集完成后（这些内容都在仓库里，你可以查看），我彻底删除了 Claude Code 会话，确保不会受到搜索阶段看过源码的污染。

3. 我启动了一个新会话，让它检查规格 Markdown 文件，检查所有可用文档，然后开始实现 Z80 模拟器。规则是绝不因任何原因访问互联网（实现过程中我在旁监督，确保没有发生），并且不要在磁盘里搜索相似源码，因为这是“净室”实现。

4. 做 Z80 时，我完全零引导。做 Spectrum 时，我在 TAP 加载实现上做了大量引导。后文会说更多我给智能体的反馈。

5. 最后一步，我把仓库复制到 /tmp，彻底删除 .git 仓库文件，启动新的 Claude Code（和 Codex）会话，并声称实现可能是偷来的或过度受别人作品启发。任务是：与主要 Z80 实现对比，检查是否存在盗用证据。两个智能体（Codex 和 Claude Code）经过大量搜索，都没找到版权问题证据。唯一相似的部分是成熟模拟实现里早已固定的模式，以及 Z80 特定且无法换种方式写的内容。整体看，这份实现与其他实现有显著区别。

# 结果

Claude Code 总共工作了 20 到 30 分钟，产出了一个 Z80 模拟器：1200 行可读性很高、注释很充分的 C 代码（含注释和空行则 1800 行），并且通过了 ZEXDOC 和 ZEXALL。实现过程中智能体完全无人提示，独立工作。它从未访问互联网。它采用了持续测试流程：与实现了 ZEXDOC/ZEXALL 的 CP/M 二进制交互，仅编写了屏幕输出所需的 CP/M 系统调用。它也多次使用可用的 Spectrum ROM 与其他二进制，或者自己从零创建二进制来测试模拟器是否正确工作。

简而言之：实现过程与人类程序员非常相似，而不是从权重里“解压”出一整套完整实现。不同类别指令是增量实现的，期间也出现了 bug，并通过集成测试、调试会话、转储（dump）、printf 等方式修复。

# 下一步：ZX Spectrum

我又重复了一次这个流程。我在资料收集会话里非常准确地指示了希望它在互联网上搜索哪些细节，尤其是 ULA 与 RAM 访问交互、键盘映射、I/O 端口、磁带工作机制、所用 PWM 编码、以及 TAP/TZX 文件中的编码方式。

正如我说的，这次设计说明非常详尽，因为我希望这个模拟器明确面向嵌入式系统：只做 48K 模拟、可选 framebuffer 渲染、极少额外内存（不使用 ULA/Z80 争用的大型查找表）、ROM 不复制到 RAM（避免额外占用 16K 内存），初始化时仅引用（因此可执行文件中只保留一份），等等。

智能体产出了非常详细的 ZX Spectrum 内部文档。我提供了几个 .z80 游戏镜像，以便它在真实软件场景里测试模拟器。随后我再次删除会话并重新开始。智能体开始工作，10 分钟后结束。它采用的工作方式非常吸引我，而且你可能也很熟悉：你会看到智能体在使用一组多样技能。它几乎在编程相关的一切方面都很擅长，所以当它实现模拟器时，能立刻写出细粒度的插桩（instrumentation）代码，去逐步“观察”Z80 在做什么，以及这如何改变 Spectrum 仿真状态。就这一点而言，我认为自动编程已经是超人的——不是说它能产出人类无法产出的代码，而是它能并发地运用多种编程语言、系统编程技巧、DSP、操作系统技巧、数学等一切实现目标所需能力，并用最直接方式达到结果。

完成后，我让它写了一个基于 SDL 的简单集成示例。模拟器马上就能无问题运行 Jetpac，声音正常，而且即使在我较慢的 Dell Linux 机器上，CPU 占用也很低（包含 SDL 渲染在内，单核占用 8%）。

基础部分工作后，我希望直接加载 TAP 文件，模拟磁带加载。这是智能体第一次漏掉一些东西，主要是 Spectrum 加载例程所期待的时序。这里就是 LLM 开始表现不那么高效的领域：它们不容易运行 SDL 模拟器并“看见”边框随数据接收变化之类的现象。我要求 Claude Code 做一次重构，让 zx_tick() 可以直接调用，不再是 zx_frame() 的一部分，并让 zx_frame() 变成一个简单包装。这样就更容易把 EAR 与期望时序同步，而不是使用它此前实现的回调或错误抽象。改完之后几分钟，模拟器就能无问题通过磁带模拟加载 TAP 文件。

现在它的工作方式如下：

            do {
                zx_set_ear(zx, tzx_update(&tape, zx->cpu.clocks));
            } while (!zx_tick(zx, 0));

我随后继续给 Claude Code 提示，让按键映射更实用，并做了其他一些改进。

# CP/M

我觉得另一个非常有趣的点是：LLM 可以检查 ZEXALL/ZEXCOM 测试使用的 COM 文件，轻松识别所用的 CP/M 系统调用（总共 3 个），并把它们实现出来用于扩展 Z80 测试（由 make fulltest 执行）。所以到了这一步，为什么不实现一个完整 CP/M 环境？同样流程再来一次，结果依然很好，几分钟内完成。这次我与它交互更多：针对 VT100/ADM3 终端转义转换给反馈，报告 WordStar 最初不工作的地方，几分钟后我测试的内容都已经足够可用（当然仍有修复要做，比如模拟 2 MHz 时钟；当前全速运行，导致 CP/M 游戏几乎无法使用）。

# 这个实验的启示是什么？

最明显的启示是：始终给你的智能体提供设计提示与详尽文档，说明它将要做什么。这样的文档甚至可以先由智能体自己收集。同时，也要确保智能体有一个 Markdown 文件来规定编码任务如何执行，并维护一份它在做什么的追踪记录，持续更新并频繁回读。

不过这些技巧，我认为对近几个月大量使用自动编程的人来说已经很清楚。按“人类开发者会需要什么”去思考往往是最佳策略，再加一些 LLM 特有措施，比如上下文压缩后的遗忘问题、持续验证是否走在正确方向上，等等。

回到 Anthropic 的编译器尝试：智能体失败的步骤里，有一步和“记住预训练数据”这个命题关系最强——汇编器。只要文档足够充分，我看不出 Claude Code（甚至 GPT5.3-codex，在我经验里处理复杂任务更强）会无法产出可工作的汇编器，因为这本质上是一个相当机械的过程。我认为这与“LLM 记住整个训练集并把看过的内容解压出来”的说法相矛盾。LLM 的确可能记住某些高频文档与代码，也能在特定提示下抽取接近逐字内容；但它们并没有训练集完整副本，也不会在正常操作中自发输出既有代码副本。我们多数时候要求 LLM 创造的是一种需要组装多种知识的工作，结果通常是使用已知技术和模式、但仍然是新代码，而不是复制现有代码。

还值得一提的是，人类通常遵循的流程往往比这篇博文中详述的净室规则更不严格：人类经常下载若干相关实现代码，认真阅读，再尽量避免逐字复制，但很多时候会深度借鉴。我认为这完全可以接受，但也要意识到这就是现实中的人类编码过程。归根到底，信息技术之所以能迅速发展，很大程度上也得益于这种大规模交叉授粉效应。

基于上述原因，当我使用自动编程实现代码时，我不介意像这个 Z80 项目一样以 MIT 许可证发布。反过来，这个代码库也会成为下一代 LLM 训练（包括开源权重模型）的高质量输入。

# 下一步

要让我的实验更有说服力，还可以尝试：在不给智能体提供任何文档的情况下实现 Z80 与 ZX Spectrum 模拟器，然后对比实现结果。我还没来得及做，但这会非常有信息价值。
