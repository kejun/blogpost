# 全文翻译：用 Claude Code 实现净室 Z80 / ZX Spectrum 模拟器

> 原文标题：Implementing a clear room Z80 / ZX Spectrum emulator with Claude Code  
> 作者：antirez  
> 原文链接：https://antirez.com/news/160

Anthropic 最近发布了一篇博文，描述了一个实验：让最新版 Opus（4.6）在“净室（clean room）”条件下，用 Rust 写一个 C 编译器。

这个实验的方法让我对他们想表达的重点有些怀疑。为什么不把 ISA 文档提供给 agent？为什么是 Rust？写 C 编译器本质上是一个大型图处理问题：这类程序在 Rust 里反而更难写。并且，在净室实验里，agent 本应可以访问所有与优化编译器相关的成熟计算机科学成果信息：很多论文都可以先整理成 markdown 文件。SSA、寄存器分配、指令选择与调度……这些都应该先完成研究，作为前置条件，然后再实现，这依然是“净室”。

不让 agent 访问互联网，也不让它看到其他编译器源码，这个选择当然是对的。不太好理解的是“几乎零引导（almost-zero steering）”原则，但如果实验目标是展示“完全自主完成大型项目”，这倒也自洽。不过我们都知道，在实践中大家并不是这么用 coding agent 的。真正高频使用 coding agent 的人都很清楚：即使你从不亲手改代码，只要关键节点点拨几下，结果质量就会发生巨大变化。

# Z80 实验

我觉得是时候自己做个类似实验了：一到两个小时内能完成、并且适配我的 Claude Code Max 套餐。我决定写一个 Z80 模拟器，然后再写一个 ZX Spectrum 模拟器（甚至还有 CP/M 模拟器，后文会提到），并采用我认为更合理的“净室”设置。结果在这里：

https://github.com/antirez/ZOT

# 我使用的流程

1. 我先写了一个 markdown 规格文件，定义我想做什么。纯英文、高层描述、定义 Z80 模拟器范围。我写了类似这样的要求：模拟器应该按“整条指令”执行，而不是“单时钟步进”，因为这个模拟器需要能跑在 RP2350 这种受限硬件上。模拟器要正确跟踪已消耗时钟周期（并明确说明后续可用它实现 ZX Spectrum 上 ULA 的内存争用），提供内存访问回调，并模拟 Z80 所有已知官方与非官方指令。

对于 Spectrum 的实现（作为下一阶段），我在 markdown 中给了更多信息：例如我希望 RGB 缓冲区如何渲染、并且该功能要可选，这样嵌入式设备在向 ST77xx（或类似）显示器传输扫描线时可以直接渲染；还要能通过 I/O 端口设置 EAR 位，以尽可能真实地模拟磁带加载；以及其他很多我对模拟器的期望。

这个文件还包含 agent 必须遵守的规则，例如：

- 禁止访问互联网，但可以使用我放在 `./z80-specs` 里的规范和测试向量文件。
- 代码应简洁清晰，不要过度复杂化。
- 每次有实质进展都要提交到 git 仓库。
- 提交前必须测试，确保产出质量高且可运行。
- 随功能增加同步补充详细测试套件；每次重大变更都要重跑测试。
- 代码注释要非常详尽：即使不熟悉 Z80 或 Spectrum 内部细节的人也能看懂。
- 不要停下来等待用户提示，用户不在键盘前。
- 在该文件末尾维护工作日志，记录已完成和待完成内容，并持续更新。
- 每次上下文压缩后都要重新阅读该文件。

2. 之后我启动了一个 Claude Code 会话，让它先去互联网上抓取 Z80（后续同样用于 Spectrum）相关的有用文档，并把有用、事实性的内容提炼成 markdown 文件。我还提供了用于 Z80 的高强度测试向量二进制文件、ZX Spectrum ROM，以及其他一些可用于验证模拟器执行正确性的二进制文件。所有资料收集完成后（都在仓库里，可以自行查看），我彻底删除了 Claude Code 会话，确保不会有“搜索阶段看到的源码”污染后续实现。

3. 我启动了新会话，让它先阅读规格 markdown 和全部本地文档，然后开始实现 Z80 模拟器。规则是：绝不访问互联网（我全程监督，确保这一点），并且不要在磁盘里搜索类似源码，因为这是净室实现。

4. Z80 实现阶段我几乎零引导。Spectrum 实现阶段，我在 TAP 加载部分做了大量引导。后文会说我具体给了什么反馈。

5. 最后一步：我把仓库复制到 `/tmp`，完全删除 `.git`，然后分别启动新的 Claude Code 与 Codex 会话，声称这份实现可能是抄袭或过度借鉴。任务是：与主流 Z80 实现逐一比对，查证是否存在盗用。两个 agent（Codex 和 Claude Code）做了大量搜索后，都没发现版权问题证据。相似部分仅限于成熟模拟器常见模式和 Z80 特有、几乎无法不同实现的部分。总体上，这份实现与其他实现在关键层面明显不同。

# 结果

Claude Code 总计工作约 20-30 分钟，产出了一个 Z80 模拟器：

- 能通过 ZEXDOC 和 ZEXALL
- 约 1200 行可读性很高、注释充分的 C 代码（含注释和空行约 1800 行）

实现过程中它完全自主、零次额外提示。它从未访问互联网。它采用的是持续测试流程：与实现了 CP/M 系统调用的 ZEXDOC/ZEXALL 二进制交互，只实现了输出结果所需的最小 CP/M syscall。它还多次使用了已有的 Spectrum ROM 与其他可用二进制，或自己生成测试二进制来验证模拟器行为。

简而言之：这个实现过程很像人类程序员，而不是从模型权重里“一次性解压”出完整实现。不同指令类别是增量实现的，期间确实出现过 bug，并通过集成测试、调试、dump、printf 等方式逐步修复。

# 下一步：ZX Spectrum

我又重复了一次流程。这次在“资料收集会话”里我明确要求它重点搜索：

- ULA 与 RAM 访问的交互
- 键盘映射
- I/O 端口
- 磁带工作方式、PWM 编码
- TAP/TZX 的编码方式

如前所述，这次设计文档非常详细，因为我希望模拟器明确面向嵌入式：

- 只做 48K 模拟
- 帧缓冲渲染可选
- 额外内存占用极小（不使用 ULA/Z80 争用的大查找表）
- ROM 初始化时仅引用，不复制到 RAM（避免额外占用 16K，只保留可执行文件中的一份）
- 等等

agent 产出了非常详尽的 ZX Spectrum 内部文档。我提供了一些 `.z80` 游戏镜像用于真实软件场景测试。然后我再次删除会话并启动新会话。agent 开始工作，约 10 分钟后完成。这个过程很有意思（你可能也很熟悉）：agent 会并行调用很多不同技能。它在编程相关方面几乎“全科”，所以在实现模拟器的同时，能立即写出细粒度 instrumentation，逐步观察 Z80 行为并关联 Spectrum 状态变化。

在这方面，我认为自动编程已经具备“超人类”的一面——并非它写出人类写不出的代码，而是它可以并发运用多种编程语言、系统技巧、DSP、操作系统知识、数学与工程手段，以最直接路径逼近结果。

完成后，我让它写了一个基于 SDL 的简单集成示例。模拟器立即可以无问题运行 Jetpac，声音正常，而且在我较慢的 Dell Linux 机器上 CPU 占用也很低（包含 SDL 渲染在内，单核 8%）。

基础功能稳定后，我希望直接加载 TAP 文件，模拟磁带读取。这里 agent 第一次出现了遗漏：主要是对 Spectrum 加载例程所期待时序的处理。LLM 在这类问题上通常会弱一些：它很难“像人一样”直接看 SDL 边框变化并理解正在接收数据的视觉反馈。

我要求 Claude Code 做一次重构：让 `zx_tick()` 可直接调用，不再嵌在 `zx_frame()` 里；`zx_frame()` 退化为一个简单包装。这样就能更直接地把 EAR 同步到它真正期望的时序点，避免此前回调/抽象层带来的偏差。改完后几分钟，模拟器就能稳定通过磁带方式加载 TAP。

现在代码是这样：

```c
do {
    zx_set_ear(zx, tzx_update(&tape, zx->cpu.clocks));
} while (!zx_tick(zx, 0));
```

之后我继续给 Claude Code 提示，把按键映射和其他细节打磨得更好。

# CP/M

我还发现了一个很有意思的点：LLM 能直接分析 ZEXALL/ZEXCOM 的 COM 文件，快速识别其中使用的 CP/M syscall（总共 3 个），并把它们实现到扩展 Z80 测试（`make fulltest`）里。

到了这一步，我想：既然如此，为什么不干脆做一个完整的 CP/M 环境？于是同样流程再来一遍，结果依旧很好，几分钟内完成。这次我在人机协作上投入更多：

- 针对 VT100 / ADM3 终端转义转换给出反馈
- 报告 WordStar 初期不工作的情况
- 几分钟内我测试的内容都能工作到足够可用

当然还有待修问题，比如要模拟 2MHz 时钟；目前全速运行导致 CP/M 游戏几乎不可用。

# 这个实验的结论是什么？

最直接的结论是：

- 一定要给 agent 设计提示
- 一定要给它足够详尽的文档

这些文档可以由 agent 自己先去收集整理。同时，最好给它一个 markdown 规则文件，明确编码流程与行为规范，并维护一份持续更新、可反复回读的过程日志。

不过这些技巧，我认为对近几个月深度使用自动编程的人来说已经很常识了。很多时候，按“人类开发者需要什么”来组织流程就是最佳策略，再叠加一些 LLM 特有措施：比如上下文压缩后的遗忘问题、持续自检是否偏航等。

回到 Anthropic 的编译器实验：他们失败的步骤里，有一部分恰恰最接近“依赖预训练记忆”的假设——汇编器。如果文档足够充分，我几乎看不到 Claude Code（以及在我经验里更擅长复杂任务的 GPT5.3-codex）会写不出可用汇编器的理由，因为它本质是机械性很强的过程。

这在我看来，与“LLM 记住了整个训练集并按需解压”的说法并不一致。LLM 当然会记住某些高频文档或代码，并在特定提示下吐出近似逐字内容；但它既不拥有训练集完整拷贝，也不会在正常工作流里自发输出现成代码副本。我们大多数时候要求它做的是：把不同知识重新组合，产出通常是“使用已知技术与模式的新代码”，而非已有代码的复制。

还值得指出的是：人类开发者往往比这篇博文里定义的净室流程更不严格。现实中，人们经常会下载多个相关实现，认真阅读后尽量避免逐字复制，但通常会强烈借鉴。我认为这完全可以接受，同时也应正视现实中的代码生产机制。毕竟信息技术高速演进，本就很大程度依赖这种大规模交叉授粉。

基于以上原因，当我用自动编程实现代码时，我不排斥将其以 MIT 许可证发布——就像这个 Z80 项目所做的那样。反过来，这样的代码库也会成为下一代 LLM（包括开源权重模型）的高质量训练输入。

# 下一步

如果要让这个实验更有说服力，一个合理的后续是：

在不给 agent 提供任何文档的情况下，再做一次 Z80 与 ZX Spectrum 模拟器实现，然后与本次结果对比。

我还没时间做这个对照实验，但它应该会很有信息量。
