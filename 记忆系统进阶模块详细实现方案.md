# 记忆系统进阶模块详细实现方案

**文档日期：** 2026年2月13日

---

## 六、冲突检测与解决系统

### 6.1 冲突类型分类器

```python
from enum import Enum
from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass
import re
import uuid
import time
import json

class ConflictType(Enum):
    """冲突类型枚举"""
    CONTRADICTION = "contradiction"      # 直接矛盾
    OUTDATED = "outdated"                # 过时信息
    INCONSISTENT = "inconsistent"         # 不一致
    DUPLICATE = "duplicate"              # 重复

@dataclass
class ConflictReport:
    """冲突报告"""
    conflict_id: str
    memory_id: str
    conflict_type: ConflictType
    version_a: int
    version_b: int
    content_a: str
    content_b: str
    severity: float  # 0-1
    evidence: List[str]
    suggested_resolution: str
    detected_at: float
    resolved: bool = False

class ConflictDetector:
    """
    冲突检测器
    
    检测多种类型的记忆冲突：
    1. 直接矛盾（A 说 X，B 说非 X）
    2. 过时信息（同一事实的新旧版本）
    3. 不一致（相关但不兼容的陈述）
    """
    
    # 矛盾模式库
    CONTRADICTION_PATTERNS = [
        (["喜欢", "爱", "偏好"], ["讨厌", "不喜欢", "厌恶"]),
        (["是", "有"], ["不是", "没有"]),
        ("肯定", "否定"),
        ("正确", "错误"),
        ("多", "少"),
        ("大", "小"),
        ("高", "低"),
    ]
    
    def __init__(self, llm_client=None):
        self.llm_client = llm_client
    
    async def detect(
        self,
        content_a: str,
        content_b: str,
        metadata_a: Dict = None,
        metadata_b: Dict = None
    ) -> List[ConflictReport]:
        """检测两个内容之间的冲突"""
        conflicts = []
        
        # 1. 检测直接矛盾
        contradictions = self._detect_contradictions(content_a, content_b)
        conflicts.extend(contradictions)
        
        # 2. 检测过时信息
        outdated = self._detect_outdated(content_a, content_b, metadata_a, metadata_b)
        conflicts.extend(outdated)
        
        # 3. 检测不一致
        inconsistent = self._detect_inconsistent(content_a, content_b, metadata_a, metadata_b)
        conflicts.extend(inconsistent)
        
        return conflicts
    
    def _detect_contradictions(
        self,
        content_a: str,
        content_b: str
    ) -> List[ConflictReport]:
        """检测直接矛盾"""
        conflicts = []
        
        a_norm = self._normalize(content_a)
        b_norm = self._normalize(content_b)
        
        assertions_a = self._extract_assertions(a_norm)
        assertions_b = self._extract_assertions(b_norm)
        
        for assert_a in assertions_a:
            for assert_b in assertions_b:
                if self._is_contradictory(assert_a, assert_b):
                    conflicts.append(ConflictReport(
                        conflict_id=str(uuid.uuid4()),
                        memory_id="",
                        conflict_type=ConflictType.CONTRADICTION,
                        version_a=0,
                        version_b=0,
                        content_a=assert_a,
                        content_b=assert_b,
                        severity=0.9,
                        evidence=[f"A: {assert_a}", f"B: {assert_b}"],
                        suggested_resolution="需人工确认最新状态",
                        detected_at=time.time()
                    ))
        
        return conflicts
    
    def _detect_outdated(
        self,
        content_a: str,
        content_b: str,
        metadata_a: Dict = None,
        metadata_b: Dict = None
    ) -> List[ConflictReport]:
        """检测过时信息"""
        conflicts = []
        
        outdated_indicators = ['之前', '以前', '曾经', '过去']
        current_indicators = ['现在', '目前', '当前', '最新']
        
        a_outdated = any(kw in content_a for kw in outdated_indicators)
        b_current = any(kw in content_b for kw in current_indicators)
        
        if a_outdated and b_current:
            conflicts.append(ConflictReport(
                conflict_id=str(uuid.uuid4()),
                memory_id="",
                conflict_type=ConflictType.OUTDATED,
                version_a=0,
                version_b=0,
                content_a=content_a[:200],
                content_b=content_b[:200],
                severity=0.6,
                evidence=["A 提及过去，B 提及现在"],
                suggested_resolution="建议保留 B，标记 A 为过时",
                detected_at=time.time()
            ))
        
        return conflicts
    
    def _detect_inconsistent(
        self,
        content_a: str,
        content_b: str,
        metadata_a: Dict = None,
        metadata_b: Dict = None
    ) -> List[ConflictReport]:
        """检测不一致"""
        topics_a = self._extract_topics(content_a)
        topics_b = self._extract_topics(content_b)
        
        overlap = len(topics_a & topics_b)
        total = len(topics_a | topics_b)
        
        if overlap > 0 and overlap < total:
            similarity = overlap / total if total > 0 else 0
            
            if 0.3 < similarity < 0.8:
                return [ConflictReport(
                    conflict_id=str(uuid.uuid4()),
                    memory_id="",
                    conflict_type=ConflictType.INCONSISTENT,
                    version_a=0,
                    version_b=0,
                    content_a=content_a[:200],
                    content_b=content_b[:200],
                    severity=0.4 * similarity,
                    evidence=[f"共同主题: {topics_a & topics_b}"],
                    suggested_resolution="建议合并或选择更准确的版本",
                    detected_at=time.time()
                )]
        
        return []
    
    def _normalize(self, text: str) -> str:
        """文本标准化"""
        text = re.sub(r'\s+', ' ', text)
        text = text.replace('，', ',').replace('。', '.')
        return text.strip()
    
    def _extract_assertions(self, text: str) -> List[str]:
        """提取关键断言"""
        sentences = text.split('.')
        return [s.strip() for s in sentences if s.strip() and len(s.strip()) > 5]
    
    def _extract_topics(self, text: str) -> set:
        """提取主题关键词"""
        words = re.findall(r'\b[\u4e00-\u9fa5a-zA-Z]+\b', text.lower())
        stopwords = {'的', '是', '在', '了', '和', '与', '或', '这', '那', '有'}
        return set(w for w in words if w not in stopwords and len(w) > 1)
    
    def _is_contradictory(self, assert_a: str, assert_b: str) -> bool:
        """判断两个断言是否矛盾"""
        a_lower = assert_a.lower()
        b_lower = assert_b.lower()
        
        for pos_keywords, neg_keywords in self.CONTRADICTION_PATTERNS:
            pos_match = any(kw in a_lower for kw in pos_keywords)
            neg_match = any(kw in b_lower for kw in neg_keywords)
            if pos_match and neg_match:
                return True
        
        return False
```

### 6.2 自动解决策略

```python
class ConflictResolver:
    """
    冲突解决器
    
    提供多种自动解决策略：
    1. 时间优先（最新优先）
    2. 置信度优先（高置信度优先）
    3. 合并策略（智能合并内容）
    """
    
    STRATEGY = Enum('STRATEGY', [
        'TIMESTAMP_FIRST',
        'CONFIDENCE_FIRST', 
        'MERGE'
    ])
    
    def __init__(self, strategy: STRATEGY = STRATEGY.TIMESTAMP_FIRST):
        self.strategy = strategy
    
    async def resolve(self, conflict: ConflictReport) -> Dict:
        """解决冲突"""
        if self.strategy == self.STRATEGY.TIMESTAMP_FIRST:
            return {
                "resolution": "timestamp_first",
                "kept_version": conflict.version_b,
                "discarded_version": conflict.version_a,
                "action": "update",
                "new_content": conflict.content_b,
                "reason": "选择更新的版本"
            }
        elif self.strategy == self.STRATEGY.MERGE:
            return {
                "resolution": "merge",
                "kept_version": "merged",
                "action": "create_new",
                "new_content": f"{conflict.content_a}\n\n[更新]\n{conflict.content_b}",
                "reason": "智能合并两个版本"
            }
        else:
            return {
                "resolution": "confidence_first",
                "action": "need_info",
                "reason": "需要置信度信息"
            }
```

---

## 七、自适应压缩引擎

### 7.1 核心架构

```python
from dataclasses import dataclass
from typing import List, Dict
from enum import Enum
import time
import math

class CompressionLevel(Enum):
    """压缩级别"""
    NONE = 0      # 不压缩
    LIGHT = 1     # 轻度压缩
    MEDIUM = 2    # 中度压缩
    AGGRESSIVE = 3 # 深度压缩

@dataclass
class CompressionResult:
    """压缩结果"""
    original_size: int
    compressed_size: int
    compression_ratio: float
    key_points_preserved: List[str]
    quality_score: float

class AdaptiveCompressionEngine:
    """
    自适应压缩引擎
    
    核心特性：
    1. 基于访问频率的动态压缩
    2. 遗忘曲线模拟
    3. 关键信息保留
    """
    
    HALF_LIFE_CONFIG = {
        'fact': 7 * 24 * 3600,       # 7天
        'preference': 30 * 24 * 3600,  # 30天
        'context': 1 * 24 * 3600,       # 1天
        'skill': 90 * 24 * 3600,        # 90天
    }
    
    def __init__(self, llm_client=None):
        self.llm_client = llm_client
    
    async def compress(
        self,
        content: str,
        category: str = 'general',
        access_history: List[Dict] = None,
        target_ratio: float = 0.5
    ) -> CompressionResult:
        """自适应压缩"""
        original_size = len(content)
        
        # 确定压缩级别
        compression_level = self._determine_level(category, access_history)
        
        # 执行压缩
        if compression_level == CompressionLevel.NONE:
            compressed = content
            key_points = self._extract_key_points(content)
        else:
            compressed, key_points = await self._do_compress(
                content, compression_level, category
            )
        
        return CompressionResult(
            original_size=original_size,
            compressed_size=len(compressed),
            compression_ratio=len(compressed) / max(original_size, 1),
            key_points_preserved=key_points,
            quality_score=self._evaluate_quality(compressed, original_size)
        )
    
    def _determine_level(
        self,
        category: str,
        access_history: List[Dict]
    ) -> CompressionLevel:
        """确定压缩级别"""
        if not access_history:
            return CompressionLevel.AGGRESSIVE
        
        now = time.time()
        recent = [
            a for a in access_history
            if now - a.get('timestamp', 0) < 7 * 24 * 3600
        ]
        
        if len(recent) > 5:
            return CompressionLevel.LIGHT
        elif len(recent) > 2:
            return CompressionLevel.MEDIUM
        else:
            return CompressionLevel.AGGRESSIVE
    
    async def _do_compress(
        self,
        content: str,
        level: CompressionLevel,
        category: str
    ) -> Tuple[str, List[str]]:
        """执行压缩"""
        if level == CompressionLevel.LIGHT:
            return self._light_compress(content)
        elif level == CompressionLevel.MEDIUM:
            return await self._medium_compress(content, category)
        else:
            return await self._aggressive_compress(content, category)
    
    def _light_compress(self, content: str) -> Tuple[str, List[str]]:
        """轻度压缩：移除冗余"""
        lines = content.split('\n')
        unique = []
        seen = set()
        
        for line in lines:
            line_norm = line.strip().lower()
            if line_norm and line_norm not in seen:
                seen.add(line_norm)
                unique.append(line)
        
        return '\n'.join(unique), self._extract_key_points(content)
    
    async def _medium_compress(
        self,
        content: str,
        category: str
    ) -> Tuple[str, List[str]]:
        """中度压缩：摘要+关键信息"""
        if not self.llm_client:
            return self._light_compress(content)
        
        prompt = f"""
请将以下{category}类记忆压缩到50%左右，保留关键信息：
{content}
返回JSON：{{"compressed": "...", "key_points": ["..."]}}
"""
        
        try:
            response = await self.llm_client.complete(prompt)
            result = json.loads(response)
            return (
                result.get('compressed', content),
                result.get('key_points', [])
            )
        except:
            return self._light_compress(content)
    
    async def _aggressive_compress(
        self,
        content: str,
        category: str
    ) -> Tuple[str, List[str]]:
        """深度压缩：极简摘要"""
        if not self.llm_client:
            return content[:200], [content[:50]]
        
        prompt = f"""
请用一句话总结以下{category}类记忆：
{content}
"""
        
        try:
            summary = await self.llm_client.complete(prompt)
            return summary.strip(), [summary[:50]]
        except:
            return content[:200], [content[:50]]
    
    def _extract_key_points(self, content: str) -> List[str]:
        """提取关键点"""
        sentences = re.split(r'[。！？\n]', content)
        return [s.strip() for s in sentences if len(s.strip()) > 20][:5]
    
    def _evaluate_quality(self, compressed: str, original: str) -> float:
        """评估压缩质量"""
        ratio = len(compressed) / max(len(original), 1)
        
        if ratio < 0.1:
            return 0.5
        elif ratio > 0.5:
            return 0.9
        else:
            return 0.7
    
    def calculate_decay(
        self,
        category: str,
        last_access_time: float,
        current_time: float = None
    ) -> float:
        """计算衰减因子"""
        current_time = current_time or time.time()
        time_diff = current_time - last_access_time
        
        half_life = self.HALF_LIFE_CONFIG.get(category, 30 * 24 * 3600)
        decay = 0.693 / half_life
        retention = math.exp(-decay * time_diff)
        
        return retention
```

---

## 八、记忆事务系统

### 8.1 事务管理器

```python
from dataclasses import dataclass
from typing import List, Dict, Callable
from enum import Enum
import asyncio
import uuid

class IsolationLevel(Enum):
    """隔离级别"""
    READ_UNCOMMITTED = "read_uncommitted"
    READ_COMMITTED = "read_committed"
    REPEATABLE_READ = "repeatable_read"

@dataclass
class MemoryTransaction:
    """记忆事务"""
    transaction_id: str
    operations: List[Dict]
    isolation_level: IsolationLevel
    created_at: float
    status: str  # active, committed, aborted

class MemoryTransactionManager:
    """
    记忆事务管理器
    
    支持 ACID 特性：
    1. Atomicity（原子性）：全有或全无
    2. Consistency（一致性）：状态一致
    3. Isolation（隔离性）：并发控制
    """
    
    def __init__(self, storage_backend, config: Dict = None):
        self.storage = storage_backend
        self.config = config or {}
        self.isolation_level = IsolationLevel(
            self.config.get('isolation_level', 'read_committed')
        )
        self._active_transactions: Dict[str, MemoryTransaction] = {}
        self._locks: Dict[str, Dict] = {}
    
    async def begin(self) -> str:
        """开始事务"""
        tx_id = str(uuid.uuid4())
        
        self._active_transactions[tx_id] = MemoryTransaction(
            transaction_id=tx_id,
            operations=[],
            isolation_level=self.isolation_level,
            created_at=time.time(),
            status='active'
        )
        
        return tx_id
    
    async def commit(self, tx_id: str):
        """提交事务"""
        tx = self._active_transactions.get(tx_id)
        if not tx:
            raise ValueError(f"Transaction not found: {tx_id}")
        
        try:
            # 执行所有操作
            for op in tx.operations:
                await self._execute_operation(tx_id, op)
            
            tx.status = 'committed'
            
        except Exception as e:
            await self.rollback(tx_id)
            raise
    
    async def rollback(self, tx_id: str):
        """回滚事务"""
        tx = self._active_transactions.get(tx_id)
        if not tx:
            return
        
        # 撤销操作
        for op in reversed(tx.operations):
            if op['type'] == 'create':
                await self.storage.delete(op['memory_id'])
            elif op['type'] == 'delete':
                # 恢复删除的记忆
                pass
        
        tx.status = 'aborted'
    
    async def add_operation(
        self,
        tx_id: str,
        operation_type: str,
        data: Dict
    ):
        """添加操作到事务"""
        tx = self._active_transactions.get(tx_id)
        if not tx:
            raise ValueError(f"Transaction not found: {tx_id}")
        
        tx.operations.append({
            'type': operation_type,
            'data': data,
            'memory_id': data.get('id')
        })
    
    async def _execute_operation(
        self,
        tx_id: str,
        operation: Dict
    ):
        """执行单个操作"""
        op_type = operation['type']
        data = operation['data']
        
        if op_type == 'create':
            await self.storage.create(data)
        elif op_type == 'update':
            await self.storage.update(data.get('id'), data)
        elif op_type == 'delete':
            await self.storage.delete(data.get('id'))
```

### 8.2 锁管理器

```python
class LockManager:
    """
    锁管理器
    
    支持：
    1. 共享锁（读锁）
    2. 排他锁（写锁）
    """
    
    def __init__(self):
        self._locks: Dict[str, Dict] = {}
        self._wait_queue: Dict[str, List] = {}
    
    async def acquire_shared(
        self,
        tx_id: str,
        key: str
    ) -> bool:
        """获取共享锁"""
        if key not in self._locks:
            self._locks[key] = {'tx_ids': [tx_id], 'exclusive': False}
            return True
        
        if not self._locks[key]['exclusive']:
            self._locks[key]['tx_ids'].append(tx_id)
            return True
        
        # 等待排他锁释放
        await self._wait(key, tx_id)
        return True
    
    async def acquire_exclusive(
        self,
        tx_id: str,
        key: str
    ) -> bool:
        """获取排他锁"""
        if key not in self._locks:
            self._locks[key] = {'tx_ids': [tx_id], 'exclusive': True}
            return True
        
        # 等待所有锁释放
        await self._wait(key, tx_id, exclusive=True)
        return True
    
    async def release(self, tx_id: str, key: str):
        """释放锁"""
        if key not in self._locks:
            return
        
        self._locks[key]['tx_ids'] = [
            t for t in self._locks[key]['tx_ids'] if t != tx_id
        ]
        
        if not self._locks[key]['tx_ids']:
            del self._locks[key]
            # 唤醒等待队列
            await self._wake_waiters(key)
    
    async def _wait(
        self,
        key: str,
        tx_id: str,
        exclusive: bool = False
    ):
        """等待锁释放"""
        if key not in self._wait_queue:
            self._wait_queue[key] = []
        
        self._wait_queue[key].append({
            'tx_id': tx_id,
            'exclusive': exclusive
        })
        
        # 实际实现需要事件等待机制
    
    async def _wake_waiters(self, key: str):
        """唤醒等待者"""
        if key not in self._wait_queue:
            return
        
        for waiter in self._wait_queue[key]:
            # 唤醒等待的事务
            pass
        
        del self._wait_queue[key]
```

---

## 九、API 接口完整设计

```python
class MemoryAPI:
    """完整记忆系统 API"""
    
    # ============ 基础 CRUD ============
    
    async def create_memory(
        self,
        content: str,
        metadata: Dict = None,
        category: str = "general",
        source: str = "user"
    ) -> MemoryRecord:
        """创建记忆"""
        pass
    
    async def retrieve(
        self,
        query: str,
        strategy: str = "auto",
        limit: int = 10,
        filters: Dict = None
    ) -> List[HybridResult]:
        """检索记忆"""
        pass
    
    async def update_memory(
        self,
        memory_id: str,
        content: str,
        reason: str = None
    ) -> MemoryRecord:
        """更新记忆"""
        pass
    
    async def delete_memory(
        self,
        memory_id: str,
        hard_delete: bool = False
    ) -> bool:
        """删除记忆"""
        pass
    
    # ============ 版本控制 ============
    
    async def get_memory_history(
        self,
        memory_id: str
    ) -> List[MemoryVersion]:
        """获取版本历史"""
        pass
    
    async def compare_versions(
        self,
        memory_id: str,
        version_a: int,
        version_b: int
    ) -> Dict:
        """比较版本"""
        pass
    
    async def restore_version(
        self,
        memory_id: str,
        version: int,
        reason: str = None
    ) -> MemoryRecord:
        """恢复到指定版本"""
        pass
    
    # ============ 冲突检测 ============
    
    async def detect_conflicts(
        self,
        memory_id: str,
        time_window: str = "30d"
    ) -> List[ConflictReport]:
        """检测冲突"""
        pass
    
    async def resolve_conflict(
        self,
        conflict_id: str,
        resolution: Dict
    ) -> Dict:
        """解决冲突"""
        pass
    
    # ============ 事务 ============
    
    async def begin_transaction(
        self,
        isolation: str = "read_committed"
    ) -> str:
        """开始事务"""
        pass
    
    async def commit_transaction(self, tx_id: str):
        """提交事务"""
        pass
    
    async def rollback_transaction(self, tx_id: str):
        """回滚事务"""
        pass
    
    # ============ 统计与管理 ============
    
    async def get_memory_stats(self) -> Dict:
        """获取记忆统计"""
        pass
    
    async def get_storage_info(self) -> Dict:
        """获取存储信息"""
        pass
    
    async def cleanup_expired(self) -> int:
        """清理过期记忆"""
        pass
```

---

## 十、配置示例

```yaml
# config.yaml
memory_system:
  # 混合检索配置
  hybrid_retrieval:
    default_weights:
      exact_match: 0.3
      semantic: 0.5
      temporal: 0.2
    thresholds:
      final_score_min: 0.1
    cache:
      enabled: true
      ttl_seconds: 300
      max_size: 10000
  
  # 冲突检测配置
  conflict_detection:
    enabled: true
    time_window: "30d"
    auto_resolve: false
    strategy: "timestamp_first"
  
  # 压缩配置
  compression:
    enabled: true
    check_interval: 3600
    max_storage_ratio: 0.8
    levels:
      fact: 7d
      preference: 30d
      context: 1d
      skill: 90d
  
  # 事务配置
  transaction:
    isolation_level: "read_committed"
    timeout_seconds: 30
  
  # 存储后端
  storage:
    vector:
      provider: "milvus"
      connection:
        uri: "localhost:19530"
      collection: "memory_chunks"
    kv:
      provider: "redis"
      connection:
        host: "localhost"
        port: 6379
```

---

## 十一、下一步计划

| 优先级 | 模块 | 说明 |
|--------|------|------|
| **P1** | 混合检索 | 核心差异化功能 |
| **P1** | 版本控制 | 解决信任问题 |
| **P2** | 冲突检测 | 痛点，三者均无 |
| **P2** | 压缩引擎 | 成本优势 |
| **P3** | 事务系统 | 数据一致性 |

---

*文档创建：2026-02-13*
